import { storage } from './firebase';\nimport { ref, uploadBytes, getDownloadURL } from 'firebase/storage';\n\n// This is a simple OCR service that uses Google Cloud Vision API\n// In a production app, you would use a server-side API call to avoid exposing API keys\n\nconst API_KEY = process.env.NEXT_PUBLIC_GOOGLE_CLOUD_VISION_API_KEY;\nconst VISION_API_URL = `https://vision.googleapis.com/v1/images:annotate?key=${API_KEY}`;\n\nexport type OCRResult = {\n  text: string;\n  items?: {\n    name: string;\n    price: number;\n    quantity?: number;\n  }[];\n  total?: number;\n  merchant?: string;\n  date?: string;\n};\n\n/**\n * Upload an image to Firebase Storage and get its public URL\n */\nasync function uploadImageToStorage(imageData: string): Promise<string> {\n  try {\n    // Convert base64 image to blob\n    const response = await fetch(imageData);\n    const blob = await response.blob();\n    \n    // Create a unique filename\n    const filename = `receipts/${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;\n    const storageRef = ref(storage, filename);\n    \n    // Upload to Firebase Storage\n    await uploadBytes(storageRef, blob);\n    \n    // Get the public URL\n    return await getDownloadURL(storageRef);\n  } catch (error) {\n    console.error('Error uploading image:', error);\n    throw new Error('Failed to upload image');\n  }\n}\n\n/**\n * Recognize text from an image using Google Cloud Vision API\n */\nexport async function recognizeText(imageData: string): Promise<OCRResult> {\n  try {\n    // First upload image to get a public URL\n    const imageUrl = await uploadImageToStorage(imageData);\n    \n    // Prepare the request body for Vision API\n    const requestBody = {\n      requests: [\n        {\n          image: {\n            source: {\n              imageUri: imageUrl\n            }\n          },\n          features: [\n            {\n              type: 'TEXT_DETECTION',\n              maxResults: 1\n            }\n          ]\n        }\n      ]\n    };\n    \n    // Call the Vision API\n    const response = await fetch(VISION_API_URL, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(requestBody)\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Vision API error: ${response.statusText}`);\n    }\n    \n    const data = await response.json();\n    \n    // Get the recognized text\n    const text = data.responses[0]?.fullTextAnnotation?.text || '';\n    \n    // Try to parse receipt details\n    const parsedResult = parseReceiptText(text);\n    \n    return {\n      text,\n      ...parsedResult\n    };\n  } catch (error) {\n    console.error('Error recognizing text:', error);\n    // Fall back to mock data for demo or development\n    if (process.env.NODE_ENV !== 'production') {\n      return getMockOCRResult();\n    }\n    throw new Error('Failed to recognize text');\n  }\n}\n\n/**\n * Parse receipt text to extract structured data\n * This is a simple implementation - in a real app, you might use more sophisticated parsing\n */\nfunction parseReceiptText(text: string): Partial<OCRResult> {\n  try {\n    const lines = text.split('\\n').filter(line => line.trim() !== '');\n    \n    // Try to identify the merchant (usually in the first few lines)\n    const merchant = lines[0];\n    \n    // Try to find the date\n    const dateRegex = /(\\d{1,2}[\\/\\-]\\d{1,2}[\\/\\-]\\d{2,4})/;\n    const dateMatch = text.match(dateRegex);\n    const date = dateMatch ? dateMatch[0] : undefined;\n    \n    // Try to find items and prices\n    const itemRegex = /([\\w\\s]+)\\s+(\\d+)(?:\\s*[xX]\\s*(\\d+))?\\s*(?:Rp|RP|IDR)?\\s*(\\d{1,3}(?:[.,]\\d{3})*(?:[.,]\\d{2})?)\\b/g;\n    let match;\n    const items = [];\n    \n    while ((match = itemRegex.exec(text)) !== null) {\n      const [, name, quantity, additionalQty, priceStr] = match;\n      const price = parseFloat(priceStr.replace(/[.,]/g, ''));\n      \n      if (!isNaN(price)) {\n        items.push({\n          name: name.trim(),\n          price,\n          quantity: additionalQty ? parseInt(additionalQty) : parseInt(quantity) || 1\n        });\n      }\n    }\n    \n    // Try to find the total\n    const totalRegex = /total\\s*(?:Rp|RP|IDR)?\\s*(\\d{1,3}(?:[.,]\\d{3})*(?:[.,]\\d{2})?)/i;\n    const totalMatch = text.match(totalRegex);\n    let total;\n    \n    if (totalMatch) {\n      total = parseFloat(totalMatch[1].replace(/[.,]/g, ''));\n    } else {\n      // If no total found, sum the items\n      total = items.reduce((sum, item) => sum + item.price, 0);\n    }\n    \n    return {\n      merchant,\n      date,\n      items,\n      total\n    };\n  } catch (error) {\n    console.error('Error parsing receipt:', error);\n    return {};\n  }\n}\n\n/**\n * Get mock OCR result for development/demo\n */\nfunction getMockOCRResult(): OCRResult {\n  return {\n    text: `\nTOKO SEMBAKO BAROKAH\nJl. Pasar Baru No. 123\nJakarta Pusat\n\nTanggal: 15/05/2023\nWaktu: 14:32\n\n--------------------------------\nBeras Pandan Wangi    5kg   Rp 75.000\nMinyak Goreng         2L    Rp 45.000\nGula Pasir            1kg   Rp 16.500\nTelur Ayam            1/2kg Rp 13.000\nTepung Terigu         1kg   Rp 12.000\nKecap Manis           1btl  Rp  9.500\n--------------------------------\nTOTAL                       Rp 171.000\n\nTerima kasih atas kunjungan Anda!\n`,\n    merchant: 'TOKO SEMBAKO BAROKAH',\n    date: '15/05/2023',\n    items: [\n      { name: 'Beras Pandan Wangi', quantity: 5, price: 75000 },\n      { name: 'Minyak Goreng', quantity: 2, price: 45000 },\n      { name: 'Gula Pasir', quantity: 1, price: 16500 },\n      { name: 'Telur Ayam', quantity: 0.5, price: 13000 },\n      { name: 'Tepung Terigu', quantity: 1, price: 12000 },\n      { name: 'Kecap Manis', quantity: 1, price: 9500 }\n    ],\n    total: 171000\n  };\n}
